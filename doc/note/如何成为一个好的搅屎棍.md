# 如何当一个好的搅屎棍

## 1.  提炼函数 (Extract Function）

```JavaScript
function printOwing(invoice) {
    printBanner();
    let outstanding = calculateOutstanding();
    //print details
    console.log(`name: ${invoice.customer}`);
    console.log(`amount: ${outstanding}`);
}

// 重构后
function printOwing(invoice) {
    printBanner();
    let outstanding = calculateOutstanding();
    printDetails(outstanding);
    function printDetails(outstanding) {
        console.log(`name: ${invoice.customer}`);
        console.log(`amount: ${outstanding}`);
    }
}
```

**动机：**当代码段可以用一个函数名来描述时，或者当代码段难以理解时，可以将其提取为一个独立的函数。

**反向重构：**内联函数

**做法：**

1. 创造一个新函数，根据这个函数的意图来对它命名（以它“做什么”来命名，而 不是以它“怎样做”命名）。 
2. 将待提炼的代码从源函数复制到新建的目标函数中。  
3. 仔细检查提炼出的代码，看看其中是否引用了作用域限于源函数、在提炼出的 新函数中访问不到的变量。若是，以参数的形式将它们传递给新函数。  
4. 所有变量都处理完之后，编译。 
5. 在源函数中，将被提炼代码段替换为对目标函数的调用。  （测试）
6. 查看其他代码是否有与被提炼的代码段相同或相似之处。如果有，考虑使用以函数调用取代内联代码令其调用提炼出的新函数。

```JavaScript
function printOwing(invoice) {
    let outstanding = 0;
    console.log("***********************");
    console.log("**** Customer Owes ****");
    console.log("***********************");
    // calculate outstanding
    for (const o of invoice.orders) {
        outstanding += o.amount;
    }
    // record due date
    const today = Clock.today;
    invoice.dueDate = new Date(
        today.getFullYear(),
        today.getMonth(),
        today.getDate() + 30
    );
    //print details
    console.log(`name: ${invoice.customer}`);
    console.log(`amount: ${outstanding}`);
    console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);
}

// 重构后
function printOwing(invoice) {

    printBanner()

    const outstanding = calculateOutstanding(invoice);

    recordDueDate(invoice);

    printDetails(invoice, outstanding);
}

function printBanner() {
    console.log("***********************");
    console.log("**** Customer Owes ****");
    console.log("***********************");
}

function printDetails(invoice, outstanding) {
    console.log(`name: ${invoice.customer}`);
    console.log(`amount: ${outstanding}`);
    console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);
}
function recordDueDate(invoice) {
    const today = Clock.today;
    invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);
}
function calculateOutstanding(invoice) {
    let result = 0;
    for (const o of invoice.orders) {
        result += o.amount;
    }
    return result;
}
```

## 2.  内联函数 (Inline Function)

```JavaScript
function getRating(driver) {
    return moreThanFiveLateDeliveries(driver) ? 2 : 1;
}
function moreThanFiveLateDeliveries(driver) {
    return driver.numberOfLateDeliveries > 5;
}

// 重构后
function getRating(driver) {
    return (driver.numberOfLateDeliveries > 5) ? 2 : 1;
}
```

**动机：**当函数的内容和名字一样容易理解时，或者当函数有太多中间层时，可以将其内联到调用处。

**反向重构：**提炼函数

**做法：**

1. 检查函数，确定它不具多态性。  
2. 找出这个函数的所有调用点。  
3. 将这个函数的所有调用点都替换为函数本体。  
4. 每次替换之后，执行测试。 
5. 删除该函数的定义。

```
function reportLines(aCustomer) {
    const lines = [];
    gatherCustomerData(lines, aCustomer);
    return lines;
}
function gatherCustomerData(out, aCustomer) {
    out.push(["name", aCustomer.name]);
    out.push(["location", aCustomer.location]);
}

// 重构后
function reportLines(aCustomer) {
    const lines = [];
    lines.push(["name", aCustomer.name]);
    lines.push(["location", aCustomer.location]);
    return lines;
}
```

## 3.  提炼变量  （Extract Variable）

```
return order.quantity * order.itemPrice -
	Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 +
	Math.min(order.quantity * order.itemPrice * 0.1, 100);

// 优化后
const basePrice = order.quantity * order.itemPrice;
const quantityDiscount = Math.max(0, order.quantity - 500) * order.itemPrice * 0.05;
const shipping = Math.min(basePrice * 0.1, 100);
return basePrice - quantityDiscount + shipping;

```

**动机：**当表达式难以理解或有重复时，可以将其提取为一个有意义的变量。

**反向重构：**内联变量

**做法：**

1. 确认要提炼的表达式没有副作用。
2. 声明一个不可修改的变量，把你想要提炼的表达式复制一份，以该表达式的结果值给这个变量赋值。 
3. 用这个新变量取代原来的表达式。 测试。  

## 4. 内联变量  （Inline Variable)

```javascript
let basePrice = anOrder.basePrice;
return (basePrice > 1000);

// 优化后
return anOrder.basePrice > 1000;
```

**动机：**当变量只被赋值一次，并且赋值的表达式简单明了时，可以将其内联到使用处。

**反向重构：**提炼变量

**做法：**

1. 检查确认变量赋值语句的右侧表达式没有副作用。 
2. 如果变量没有被声明为不可修改，先将其变为不可修改，并执行测试。 这是为了确保该变量只被赋值一次。
3. 找到第一处使用该变量的地方，将其替换为直接使用赋值语句的右侧表达式。 测试。 
4. 重复前面两步，逐一替换其他所有使用该变量的地方。 
5. 删除该变量的声明点和赋值语句。

## 5.  改变函数声明  （Change Function Declaration )

```javascript
function circum(radius) {
	return 2 * Math.PI * radius;
}

// 优化后
function circumference(radius) {
	return 2 * Math.PI * radius;
}

// 为了兼容的迁移式优化
function circum(radius) {
	return circumference(radius);
}
function circumference(radius) {
	return 2 * Math.PI * radius;
}
```

**动机：**当函数的名字、参数或返回值不符合需求或不清晰时，可以修改它们以提高可读性和可用性。

**做法：**

1. 如果想要移除一个参数，需要先确定函数体内没有使用该参数。 
2. 修改函数声明，使其成为你期望的状态。 
3. 找出所有使用旧的函数声明的地方，将它们改为使用新的函数声明。 测试。  

## 6.  封装变量  (Encapsulate Variable)

```javascript
let defaultOwner = {firstName: "Martin", lastName: "Fowler"};

// 优化后
let defaultOwnerData = {firstName: "Martin", lastName: "Fowler"};
export function defaultOwner() {return defaultOwnerData;}
export function setDefaultOwner(arg) {defaultOwnerData = arg;}
```

**动机：**当变量被多处使用或可能被修改时，可以将其封装为一个函数或对象，以便控制访问和更新。

**做法：**

1. 创建封装函数，在其中访问和更新变量值。 
2. 执行静态检查。 逐一修改使用该变量的代码，
3. 将其改为调用合适的封装函数。每次替换之后， 执行测试。 限制变量的可见性。  
4. 如果变量的值是一个记录，考虑使用封装记录。  

**补充：**

 有很多时候，我需要把封装做得更深入，不仅控制对变量引用的修改， 还要控制对变量内容的修改。  

 对于列表数据，我尤其常用这一招（做法1）。  

```javascript
let defaultOwnerData = {firstName: "Martin", lastName: "Fowler"};
export function defaultOwner() {return Object.assign({}, defaultOwnerData);}
export function setDefaultOwner(arg) {defaultOwnerData = arg;}
```

 但在使用副本的做 法时，我必须格外小心：有些代码可能希望能修改共享的数据 ：（做法2）

```javascript
let defaultOwnerData = {firstName: "Martin", lastName: "Fowler"};
export function defaultOwner() {return new Person(defaultOwnerData);}
export function setDefaultOwner(arg) {defaultOwnerData = arg;}
class Person {
  constructor(data) {
    this._lastName = data.lastName;
    this._firstName = data.firstName
  }
  get lastName() {return this._lastName;}
  get firstName() {return this._firstName;}
// and so on for other properties
```

请记住，前面提到的数据复制、类封装等措施，都只在数据记录结构中深入 了一层。如果想走得更深入，就需要更多层级的复制或是封装。

## 7. 变量改名 （Rename Variable）

```javascript
let a = height * width;

// 优化后
let area = height * width;
```

**动机：**当变量的名字不清晰或不符合规范时，可以将其改为一个更有意义或更统一的名字。

**做法：**

1. 如果变量被广泛使用，考虑运用封装变量将其封装起来。
2. 找出所有使用该变量的代码，逐一修改。

## 8.  引入参数对象  （Introduce Parameter Object ） 

```javascript
function amountInvoiced(startDate, endDate) {...}
function amountReceived(startDate, endDate) {...}
function amountOverdue(startDate, endDate) {...}

// 重构后
function amountInvoiced(aDateRange) {...}
function amountReceived(aDateRange) {...}
function amountOverdue(aDateRange) {...}
```

**动机：**当函数有多个参数时，可以将它们封装为一个对象，以便简化调用和管理。

**做法：**

1. 创建合适的数据结构（测试）
2. 使用改变函数声明给原来的函数新增一个参数，类型是新建的数据结构。（测试）
3. 调整所有调用者，传入新数据结构的适当实例。每修改一处，执行测试。
4. 用新数据结构中的每项元素，逐一取代参数列表中与之对应的参数项，然后删除原来的参数。（测试） 

```javascript
// 温度读数的数据
const station = {
    name: "ZB1",
    readings: [
        { temp: 47, time: "2016-11-10 09:10" },
        { temp: 53, time: "2016-11-10 09:20" },
        { temp: 58, time: "2016-11-10 09:30" },
        { temp: 53, time: "2016-11-10 09:40" },
        { temp: 51, time: "2016-11-10 09:50" },
    ],
};

// 责找到超出指定范围的温度读数
function readingsOutsideRange(station, min, max) {
    return station.readings
        .filter(r => r.temp < min || r.temp > max);
}


// 调用方
readingsOutsideRange(station,
    operatingPlan.temperatureFloor,
    operatingPlan.temperatureCeiling);


// 重构后
const station = {
    name: "ZB1",
    readings: [
        { temp: 47, time: "2016-11-10 09:10" },
        { temp: 53, time: "2016-11-10 09:20" },
        { temp: 58, time: "2016-11-10 09:30" },
        { temp: 53, time: "2016-11-10 09:40" },
        { temp: 51, time: "2016-11-10 09:50" },
    ],
};

function readingsOutsideRange(station, range) {
    return station.readings
        .filter(r => !range.contains(r.temp));
}

const range = new NumberRange(operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling);

readingsOutsideRange(station, range);

// 搬移行为
class NumberRange {
    constructor(min, max) {
        this._data = { min: min, max: max };
    }
    contains(arg) { return (arg >= this.min && arg <= this.max); }

    get min() { return this._data.min; }
    get max() { return this._data.max; }
}
```

## 9.  函数组合成类  （Combine Functions into Class）

```javascript
function base(aReading) {...}
function taxableCharge(aReading) {...}
function calculateBaseCharge(aReading) {...}

// 重构后
class Reading {
  base() {...}
  taxableCharge() {...}
  calculateBaseCharge() {...}
}
```

**动机：**当函数操作同一组数据时，可以将它们组合为一个类，以便利用封装和继承等面向对象的特性。

**做法：**

运用封装记录对多个函数共用的数据记录加以封装。

1. > 如果多个函数共用的数据还未组织成记录结构，则先运用引入参数对象将其组织成记录。  

对于使用该记录结构的每个函数，运用搬移函数将其移入新类。

1. > 如果函数调用时传入的参数已经是新类的成员，则从参数列表中去除之。

用以处理该数据记录的逻辑可以用提炼函数提炼出来，并移入新类。

## 10. 函数组合成变换（Combine Functions into Transform）

```javascript
function base(aReading) {...}
function taxableCharge(aReading) {...}

// 重构后
function enrichReading(argReading) {
  const aReading = _.cloneDeep(argReading);
  aReading.baseCharge = base(aReading);
  aReading.taxableCharge = taxableCharge(aReading);
  return aReading;
}
```

**动机：**当函数操作同一组数据，但不需要更新数据时，可以将它们组合为一个变换，以便生成新的数据而不影响原始数据。

**做法：**

1. 创建一个变换函数，输入参数是需要变换的记录，并直接返回该记录的值。 
2. 挑选一块逻辑，将其主体移入变换函数中，把结果作为字段添加到输出记录中。修改客户端代码，令其使用这个新字段。

```javascript
// 旧代码
function reverse(array) {
  return array.slice().reverse();
}

function first(array) {
  return array[0];
}

function toUpper(str) {
  return str.toUpperCase();
}

let array = ["apple", "banana", "cherry"];
let result = toUpper(first(reverse(array))); // CHERRY

// 新代码
function compose(...fns) {
  return function (x) {
    return fns.reduceRight((v, f) => f(v), x);
  };
}

let getFirstInUpperCase = compose(toUpper, first, reverse);
let result = getFirstInUpperCase(array); // CHERRY
```

## 11.  拆分阶段（Split Phase） 

```javascript
const orderData = orderString.split(/\s+/);
const productPrice = priceList[orderData[0].split("-")[1]];
const orderPrice = parseInt(orderData[1]) * productPrice;

// 重构后
const orderRecord = parseOrder(order);
const orderPrice = price(orderRecord, priceList);
function parseOrder(aString) {
  const values = aString.split(/\s+/);
  return ({
    productID: values[0].split("-")[1],
    quantity: parseInt(values[1]),
  });
}
function price(order, priceList) {
	return order.quantity * priceList[order.productID];
}
```

**动机：**当函数有多个逻辑步骤时，可以将它们拆分为不同的函数，以便提高可读性和复用性。

**做法：**

1. 将第二阶段的代码提炼成独立的函数。 （测试）
2. 引入一个中转数据结构，将其作为参数添加到提炼出的新函数的参数列表中。（测试）
3. 逐一检查提炼出的“第二阶段函数”的每个参数。如果某个参数被第一阶段用到，就将其移入中转数据结构。每次搬移之后都要执行测试。  
4. 对第一阶段的代码运用提炼函数，让提炼出的函数返回中转数据结构。 

## 12.  封装记录（Encapsulate Record）  

```javascript
organization = {name: "Acme Gooseberries", country: "GB"};

// 重构后
class Organization {
  constructor(data) {
    this._name = data.name;
    this._country = data.country;
  }
  get name() {return this._name;}
  set name(arg) {this._name = arg;}
  get country() {return this._country;}
  set country(arg) {this._country = arg;}
}
```

记录型结构可以有两种类型：一种需要声明合法的字段名字，另一种可以随便用任何字段名字。后者常由语言库本身实现，并通过类的形式提供出来，这些类称为散列（hash）、映射（map）、散列映射（hashmap）、字典（dictionary） 或关联数组（associative array）等。  

**动机：**当数据结构是一个简单的记录时，可以将其封装为一个类，以便添加行为和控制访问。

**做法：**

1.  对持有记录的变量使用封装变量，将其封装到一个函数中。 
2. 创建一个类，将记录包装起来，并将记录变量的值替换为该类的一个实例。然后在类上定义一个访问函数，用于返回原始的记录。修改封装变量的函数，令其使用这个访问函数。（测试）
3. 新建一个函数，让它返回该类的对象，而非那条原始的记录。  
4. 对于该记录的每处使用点，将原先返回记录的函数调用替换为那个返回实例对象的函数调用。使用对象上的访问函数来获取数据的字段，如果该字段的访问函数还不存在，那就创建一个。每次更改之后运行测试。
5. 移除类对原始记录的访问函数，那个容易搜索的返回原始数据的函数也要一并删除。（测试）
6. 如果记录中的字段本身也是复杂结构，考虑对其再次应用封装记录或 封装集合手法。

## 13.  封装集合（Encapsulate Collection）  

```javascript
class Person {
  get courses() {return this._courses;}
  set courses(aList) {this._courses = aList;}

// 重构后
class Person {
  get courses() {return this._courses.slice();}
  addCourse(aCourse) { ... }
  removeCourse(aCourse) { ... }
```

**动机：**当数据结构是一个集合时，可以将其封装为一个类，以便隐藏实现细节和提供统一的接口。

**做法：**

1. 如果集合的引用尚未被封装起来，先用封装变量封装它。
2. 在类上添加用于“添加集合元素”和“移除集合元素”的函数。  
3. 执行静态检查。  
4. 查找集合的引用点。如果有调用者直接修改集合，令该处调用使用新的添加/ 移除元素的函数。每次修改后执行测试。  
5. 修改集合的取值函数，使其返回一份只读的数据，可以使用只读代理或数据副本。（测试）  

## 14.  以对象取代基本类型（Replace Primitive with Object）

```javascript
orders.filter(o => "high" === o.priority || "rush" === o.priority);

// 重构后
orders.filter(o => o.priority.higherThan(new Priority("normal")))
```

**动机：**当基本类型数据有额外的含义或行为时，可以将其替换为一个对象，以便增加可读性和扩展性。

**做法：**

1. 如果变量尚未被封装起来，先使用封装变量封装它。  
2.  为这个数据值创建一个简单的类。类的构造函数应该保存这个数据值，并为它提供一个取值函数。  
3.  执行静态检查。  
4. 修改第一步得到的设值函数，令其创建一个新类的对象并将其存入字段，如果有必要的话，同时修改字段的类型声明。  
5. 修改取值函数，令其调用新类的取值函数，并返回结果。  （测试）
6. 考虑对第一步得到的访问函数使用函数改名，以便更好反映其用途。  
7. 考虑应用将引用对象改为值对象或将值对象改为引用对象，明确指出新对象的角色是值对象还是引用对象。

```javascript
// 旧代码
let phoneNumber = "123-4567";

// 新代码
class PhoneNumber {
  constructor(phoneNumber) {
    this.phoneNumber = phoneNumber;
  }

  getAreaCode() {
    return this.phoneNumber.substring(0, 3);
  }

  getNumber() {
    return this.phoneNumber.substring(4);
  }

  toString() {
    return this.phoneNumber;
  }
}

let phoneNumber = new PhoneNumber("123-4567");
```

## 15.  以查询取代临时变量（Replace Temp with Query） 

```javascript
const basePrice = this._quantity * this._itemPrice;
if (basePrice > 1000)
	return basePrice * 0.95;
else
	return basePrice * 0.98;

// 重构后
get basePrice() {this._quantity * this._itemPrice;}
...
if (this.basePrice > 1000)
	return this.basePrice * 0.95;
else
	return this.basePrice * 0.98;
```

**动机：**当临时变量是由一个表达式计算得到时，可以将其替换为一个查询函数，以便消除重复和提高可测试性。

**做法：**

1. 检查变量在使用前是否已经完全计算完毕，检查计算它的那段代码是否每次都能得到一样的值。
2. 如果变量目前不是只读的，但是可以改造成只读变量，那就先改造它。  （测试）
3. 将为变量赋值的代码段提炼成函数。 
4.  应用内联变量手法移除临时变量。  （测试）

## 16.  提炼类（Extract Class）  

```javascript
class Person {
  get officeAreaCode() {return this._officeAreaCode;}
  get officeNumber() {return this._officeNumber;}


// 重构后
class Person {
  get officeAreaCode() {return this._telephoneNumber.areaCode;}
  get officeNumber() {return this._telephoneNumber.number;}
}
class TelephoneNumber {
  get areaCode() {return this._areaCode;}
  get number() {return this._number;}
}
```

**动机：**当一个类承担了过多的责任，或者难以理解时，可以将一部分功能和数据提取出来，形成一个新的类。

**反向重构：**内联类

**做法：**

1. 决定如何分解类所负的责任 。
2. 创建一个新的类，用以表现从旧类中分离出来的责任。  

如果旧类剩下的责任与旧类的名称不符，为旧类改名。  

1. 构造旧类时创建一个新类的实例，建立“从旧类访问新类”的连接关系。 对于你想搬移的每一个字段，运用搬移字段搬移之。 每次更改后运行测试。 
2. 使用搬移函数将必要函数搬移到新类。先搬移较低层函数（也就是“被其他函数调用”多于“调用其他函数”者）。每次更改后运行测试。
3. 检查两个类的接口，去掉不再需要的函数，必要时为函数重新取一个适合新环境的名字。   
4. 决定是否公开新的类。如果确实需要，考虑对新类应用将引用对象改为值对象使其成为一个值对象。  

## 17.  内联类（Inline Class）

```javascript
class Person {
  get officeAreaCode() {return this._telephoneNumber.areaCode;}
  get officeNumber() {return this._telephoneNumber.number;}
}
class TelephoneNumber {
  get areaCode() {return this._areaCode;}
  get number() {return this._number;}
}

// 重构后
class Person {
  get officeAreaCode() {return this._officeAreaCode;}
  get officeNumber() {return this._officeNumber;}
```

**动机：**当一个类没有承担足够的责任，或者只是另一个类的委托者时，可以将它的功能和数据合并到另一个类中。

**反向重构：**提炼类

**做法：**

1. 对于待内联类（源类）中的所有public函数，在目标类上创建一个对应的函数，新创建的所有函数应该直接委托至源类。  
2. 修改源类public方法的所有引用点，令它们调用目标类对应的委托方法。每次更改后运行测试。
3. 将源类中的函数与数据全部搬移到目标类，每次修改之后进行测试，直到源类变成空壳为止。 
4. 删除源类  

## 18.  隐藏委托关系（Hide Delegate）  

```javascript
manager = aPerson.department.manager;

// 重构后
manager = aPerson.manager;
class Person {
	get manager() {return this.department.manager;}
```

**动机：**当一个类使用了另一个类的对象，而客户端需要知道这种关系时，可以将这种关系隐藏起来，让客户端只通过第一个类来访问第二个类的对象。

**反向重构：**移除中间人

**做法：**

1.  对于每个委托关系中的函数，在服务对象端建立一个简单的委托函数。  
2.  调整客户端，令它只调用服务对象提供的函数。每次调整后运行测试。  
3.  如果将来不再有任何客户端需要取用Delegate（受托类），便可移除服务对象中的相关访问函数。  

## 19.  移除中间人（Remove Middle Man）  

```javascript
manager = aPerson.manager;
class Person {
	get manager() {return this.department.manager;}

// 重构后
manager = aPerson.department.manager;
```

**动机：**当一个类有大部分的接口都委托给了同一个调用类时，可以将这些接口直接移动到调用类中，减少不必要的中间层。

**反向重构：**隐藏委托关系

**做法：**

1.  为受托对象创建一个取值函数。  
2.  对于每个委托函数，让其客户端转为连续的访问函数调用。每次替换后运行测试。  

## 20.  替换算法（Substitute Algorithm）

```javascript
function foundPerson(people) {
  for (let i = 0; i < people.length; i++) {
    if (people[i] === "Don") {
      return "Don";
    }
    if (people[i] === "John") {
      return "John";
    }
    if (people[i] === "Kent") {
      return "Kent";
    }
  }
  return "";
}

// 重构后
function foundPerson(people) {
  const candidates = ["Don", "John", "Kent"];
  return people.find(p => candidates.includes(p)) || '';
}
```

**动机：**当一个函数的实现过于复杂或者效率低下时，可以用另一种更简单或者更高效的算法来替换它。

**做法：**

1. 整理一下待替换的算法，保证它已经被抽取到一个独立的函数中。  
2.  先只为这个函数准备测试，以便固定它的行为。  
3.  准备好另一个（替换用）算法。
4.  执行静态检查。   
5.  运行测试，比对新旧算法的运行结果。如果测试通过，那就大功告成；否则， 在后续测试和调试过程中，以旧算法为比较参照标准。    

## 21.  搬移函数（Move Function）  

```javascript
class Account {
	get overdraftCharge() {...}

// 重构后
class AccountType {
	get overdraftCharge() {...}
```

**动机：**当一个函数与另一个类的对象有更多的合作关系时，可以将这个函数搬移到另一个类中，减少类之间的耦合。

**做法：**

1.  检查函数在当前上下文里引用的所有程序元素（包括变量和函数），考虑是否需要将它们一并搬移  
2.  检查待搬移函数是否具备多态性。  
3.  将函数复制一份到目标上下文中。调整函数，使它能适应新家。 
4.  执行静态检查。  
5.  设法从源上下文中正确引用目标函数。  
6.  修改源函数，使之成为一个纯委托函数。  （测试）
7.  考虑对源函数使用内联函数 

## 22.  搬移字段（Move Field）  

```javascript
class Customer {
  get plan() {return this._plan;}
  get discountRate() {return this._discountRate;}

// 重构后
class Customer {
  get plan() {return this._plan;}
  get discountRate() {return this.plan.discountRate;}
```

**动机：**当一个字段被另一个类的对象更多地使用时，可以将这个字段搬移到另一个类中，提高内聚性。

**做法：**

1. 确保源字段已经得到了良好封装。 测试。 
2. 在目标对象上创建一个字段（及对应的访问函数）。 
3. 执行静态检查。 确保源对象里能够正常引用目标对象。   
4. 调整源对象的访问函数，令其使用目标对象的字段。   
5. 移除源对象上的字段。  

```javascript
// 重构前
class Account {
  constructor(number, type) {
    this._number = number;
    this._type = type;
  }
  get interestRate() {return this._type.interestRate;}
}
class AccountType {
  constructor(nameString, interestRate) {
    this._name = nameString;
    this._interestRate = interestRate;
  }
  get interestRate() {return this._interestRate;}
}

// 重构后
class Account {
  constructor(number, interestRate) {
    this._number = number;
    this._interestRate = interestRate; // 将字段搬移到这个类中
  }
  get interestRate() {return this._interestRate;}
}

class AccountType {
  constructor(nameString) {
    this._name = nameString;
  }
}
```

## 23.  搬移语句到函数（Move Statements into Function） 

```javascript
result.push(`<p>title: ${person.photo.title}</p>`);
result.concat(photoData(person.photo));
function photoData(aPhoto) {
  return [
    `<p>location: ${aPhoto.location}</p>`,
    `<p>date: ${aPhoto.date.toDateString()}</p>`,
  ];
}

// 重构后
result.concat(photoData(person.photo));
function photoData(aPhoto) {
  return [
    `<p>title: ${aPhoto.title}</p>`,
    `<p>location: ${aPhoto.location}</p>`,
    `<p>date: ${aPhoto.date.toDateString()}</p>`,
  ];
}
```

**动机：**当一个函数中有一些语句与另一个函数的功能重复时，可以将这些语句搬移到另一个函数中，消除重复代码。

**反向重构：**搬移语句到调用者

**做法：**

1. 如果重复的代码段离调用目标函数的地方还有些距离，则先用移动语句将这些语句挪动到紧邻目标函数的位置。  
2. 如果目标函数仅被唯一一个源函数调用，那么只需将源函数中的重复代码段剪切并粘贴到目标函数中即可，然后运行测试。本做法的后续步骤至此可以忽略。  
3. 如果函数不止一个调用点，那么先选择其中一个调用点应用提炼函数，将待搬移的语句与目标函数一起提炼成一个新函数。给新函数取个临时的名字，只要易于搜索即可。
4. 调整函数的其他调用点，令它们调用新提炼的函数。每次调整之后运行测试。
5. 完成所有引用点的替换后，应用内联函数将目标函数内联到新函数里，并移除原目标函数。  
6. 对新函数应用函数改名，将其改名为原目标函数的名字。

## 24.  搬移语句到调用者（Move Statements to Callers） 

```javascript
emitPhotoData(outStream, person.photo);
function emitPhotoData(outStream, photo) {
  outStream.write(`<p>title: ${photo.title}</p>\n`);
  outStream.write(`<p>location: ${photo.location}</p>\n`);
}

// 重构后
emitPhotoData(outStream, person.photo);
outStream.write(`<p>location: ${person.photo.location}</p>\n`);
function emitPhotoData(outStream, photo) {
	outStream.write(`<p>title: ${photo.title}</p>\n`);
}
```

动机：当一个函数中有一些语句在不同的调用场景下有差异时，可以将这些语句搬移到调用者位置，增加灵活性。

1. 在多个地方共用的行为，如今需要在某些调用点面前表现出不同的行为  
2.  有时调用点和调用者之间的边界已经相去甚远，此时便只能重新进行设计了  
3. 若真如此，最好的办法是先用内联函数合并双方的内容，调整语句的顺序，再提炼出新的 函数来，以形成更合适的边界。  

反向重构：搬移语句到函数

做法：

1. 最简单的情况下，原函数非常简单，其调用者也只有寥寥一两个，此时只需把 要搬移的代码从函数里剪切出来并粘贴回调用端去即可，必要的时候做些调整。运行测试。如果测试通过，那就大功告成，本手法可以到此为止。  
2. 若调用点不止一两个，则需要先用提炼函数将你不想搬移的代码提炼成一个新函数，函数名可以临时起一个，只要后续容易搜索即可。
3. 对原函数应用内联函数
4. 对提炼出来的函数应用改变函数声明，令其与原函数使用同一个名字。

## 25.  以函数调用取代内联代码（Replace Inline Code with Function Call）  

```javascript
let appliesToMass = false;
for(const s of states) {
	if (s === "MA") appliesToMass = true;
}

// 重构后
appliesToMass = states.includes("MA");
```

**动机：**提高代码的可读性和复用性，避免重复代码。

**做法：**将内联代码替代为对一个既有函数的调用。 

## 26.  移动语句（Slide Statements）  

```javascript
const pricingPlan = retrievePricingPlan();
const order = retreiveOrder();
let charge;
const chargePerUnit = pricingPlan.unit;

// 重构后
const pricingPlan = retrievePricingPlan();
const chargePerUnit = pricingPlan.unit;
const order = retreiveOrder();
let charge;
```

**动机：**改善代码的逻辑顺序和结构，减少局部变量的作用域。

**做法：**

1. 确定待移动的代码片段应该被搬往何处。仔细检查待移动片段与目的地之间的语句，看看搬移后是否会影响这些代码正常工作。如果会，则放弃这项重构。  
2. 剪切源代码片段，粘贴到上一步选定的位置上。  （测试）

## 27.  拆分循环（Split Loop）  

```javascript
let averageAge = 0;
let totalSalary = 0;
for (const p of people) {
  averageAge += p.age;
  totalSalary += p.salary;
}
averageAge = averageAge / people.length;

// 重构后
let totalSalary = 0;
for (const p of people) {
	totalSalary += p.salary;
}
let averageAge = 0;
for (const p of people) {
	averageAge += p.age;
}
averageAge = averageAge / people.length;
```

**动机：**将一个循环分成多个循环，每个循环只做一件事，提高代码的清晰度和可维护性。

**做法：**

1. 复制一遍循环代码。  
2.  识别并移除循环中的重复代码，使每个循环只做一件事。  （测试）
3.  完成循环拆分后，考虑对得到的每个循环应用提炼函数。  

## 28.  以管道取代循环（Replace Loop with Pipeline）  

```javascript
const names = [];
for (const i of input) {
  if (i.job === "programmer")
  	names.push(i.name);
}

// 重构后
const names = input
  .filter(i => i.job === "programmer")
  .map(i => i.name)
```

如今越来越多的编程语言都提供了更好的语言结构来处理迭代过程，这种结构就叫作**集合管道（collection pipeline）**。集合管道是这样一种技术，它允许我使用一组运算来描述集合的迭代过程，其中每种运算接收的入参和返回值都是一个集合。

**动机：**使用函数式编程的风格，将一个数组的操作用一系列函数组合起来，避免使用中间变量和副作用。

做法：

1. 创建一个新变量，用以存放参与循环过程的集合。  
2. 从循环顶部开始，将循环里的每一块行为依次搬移出来，在上一步创建的集合 变量上用一种管道运算替代之。每次修改后运行测试。  
3.  搬移完循环里的全部行为后，将循环整个删除。  

## 29.  移除死代码（Remove Dead Code） 

```javascript
if(false) {
	doSomethingThatUsedToMatter();
}

// 重构后
// 删除
```

**动机：**删除不会被执行或者不再需要的代码，减少代码的冗余和混乱。

**做法：**

1. 如果死代码可以从外部直接引用，比如它是一个独立的函数时，先查找一下还有无调用点。  
2.  将死代码移除。  （测试）

## 30.  拆分变量（Split Variable）   

```javascript
let temp = 2 * (height + width);
console.log(temp);
temp = height * width;
console.log(temp);

// 重构后
const perimeter = 2 * (height + width);
console.log(perimeter);
const area = height * width;
console.log(area);
```

**循环变量（loop variable）** 会随循环的每次运行而改变（例如for（let i=0; i<10; i++）语句中的i）。

**结果收集变量（collecting variable）**负责将“通过整个函数的运算”而构成的某个值收集起来。

**动机：**（除以上两种情况）将一个变量拆分成多个变量，每个变量只有一个用途和含义，提高代码的可读性和可测试性。

**做法：**

1. 在待分解变量的声明及其第一次被赋值处，修改其名称。  

如果稍后的赋值语句是“i=i+某表达式形式”，意味着这是一个结果收集变 量，就不要分解它。结果收集变量常用于累加、字符串拼接、写入流或者向集 合添加元素。  

1.  如果可能的话，将新的变量声明为不可修改。  
2.  以该变量的第二次赋值动作为界，修改此前对该变量的所有引用，让它们引用新变量。  (测试)
3.  重复上述过程。每次都在声明处对变量改名，并修改下次赋值之前的引用，直至到达最后一处赋值。   

## 31.  字段改名（Rename Field）

```javascript
class Organization {
	get name() {...}
}

// 重构后
class Organization {
	get title() {...}
}
```

**动机：**命名很重要，对于程序中广泛使用的记录结构，其中字段的命名格外重要。

**做法：**

1.  如果记录的作用域较小，可以直接修改所有该字段的代码，然后测试。后面的步骤就都不需要了。 
2.  如果记录还未封装，请先使用封装记录。  
3.  在对象内部对私有字段改名，对应调整内部访问该字段的函数。  （测试）
4.  如果构造函数的参数用了旧的字段名，运用改变函数声明将其改名。 
5.  运用函数改名给访问函数改名。 

## 32.  以查询取代派生变量（Replace Derived Variable with Query）    

```javascript
get discountedTotal() {return this._discountedTotal;}
set discount(aNumber) {
  const old = this._discount;
  this._discount = aNumber;
  this._discountedTotal += old - aNumber;
}

// 重构后
get discountedTotal() {return this._baseTotal - this._discount;}
set discount(aNumber) {this._discount = aNumber;}
```

**动机：**避免使用派生变量存储计算结果，而是使用函数封装计算逻辑，提高代码的一致性和可维护性。

做法：

1. 识别出所有对变量做更新的地方。如有必要，用拆分变量分割各个更新点。  
2.  新建一个函数，用于计算该变量的值。  
3.  用引入断言断言该变量和计算函数始终给出同样的值。  （测试）

 

> 如有必要，用封装变量将这个断言封装起来。

  

1.  修改读取该变量的代码，令其调用新建的函数。  （测试）
2.  用移除死代码去掉变量的声明和赋值。  

```javascript
// 以查询取代派生变量
class Order {
  constructor(basePrice, discount) {
    this.basePrice = basePrice;
    this.discount = discount;
    // this.totalPrice = basePrice - discount; // 派生变量
  }

  // 查询函数
  getTotalPrice() {
    return this.basePrice - this.discount;
  }
}
```

## 33.  将引用对象改为值对象（Change Reference to Value）  

```javascript
class Product {
	applyDiscount(arg) {this._price.amount -= arg;}

// 重构后
class Product {
  applyDiscount(arg) {
  	this._price = new Money(this._price.amount - arg, this._price.currency);
  }
```

把一个对象（或数据结构）嵌入另一个对象时，位于内部的这个对象可以被视为引用对象，也可以被视为值对象:  

- 如果将内部对象视为**引用对象**，在更新其属性时，我会保留原对象不动，更新内部对象的属性；
- 如果将其视为**值对象**，我就会替换整个内部对象，新换上的对象会有我想要的属性值。 

**动机：**当一个对象是不可变的，并且只有其数据才影响其行为时，可以将其改为值对象，提高代码的效率和简洁性。

**反向重构：**将值对象改为引用对象

**做法：**

1. 检查重构目标是否为不可变对象，或者是否可修改为不可变对象。  
2.  用移除设值函数逐一去掉所有设值函数。  
3.  提供一个基于值的相等性判断函数，在其中使用值对象的字段。 

## 34.  将值对象改为引用对象（Change Value to Reference）  

```javascript
let customer = new Customer(customerData);

// 重构后
let customer = customerRepository.get(customerData.id);
```

**动机：**当一个对象是可变的，并且需要在多个地方共享时，可以将其改为引用对象，避免数据的不一致和冗余。

**反向重构：**将引用对象改为值对象

**做法：**

1.  为相关对象创建一个仓库（如果还没有这样一个仓库的话）。  
2.  确保构造函数有办法找到关联对象的正确实例。  
3.  修改宿主对象的构造函数，令其从仓库中获取关联对象。每次修改后执行测试。  

## 35.  分解条件表达式（Decompose Conditional）  

```javascript
if (!aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd))
	charge = quantity * plan.summerRate;
else
	charge = quantity * plan.regularRate + plan.regularServiceCharge;

// 重构后
if (summer())
	charge = summerCharge();
else
	charge = regularCharge();
```

**动机：**将复杂的条件表达式拆分成多个简单的条件表达式，提高代码的可读性和可测试性。

**做法：**对条件判断和每个条件分支分别运用提炼函数手法。  

## 36.  合并条件表达式（Consolidate Conditional Expression）

```javascript
if (anEmployee.seniority < 2) return 0;
if (anEmployee.monthsDisabled > 12) return 0;
if (anEmployee.isPartTime) return 0;

if (isNotEligibleForDisability()) return 0;
function isNotEligibleForDisability() {
  return ((anEmployee.seniority < 2)
    || (anEmployee.monthsDisabled > 12)
    || (anEmployee.isPartTime));
}
```

**动机：**将多个相同或相似的条件表达式合并成一个条件表达式，减少代码的重复和分支。

**做法：**

1. 确定这些条件表达式都没有副作用。  

> 如果某个条件表达式有副作用，可以先用将查询函数和修改函数分离处理。  

1.  使用适当的逻辑运算符，将两个相关条件表达式合并为一个  (测试)

  

>  顺序执行的条件表达式用逻辑或来合并，嵌套的if语句用逻辑与来合并。 

 

1.  重复前面的合并过程，直到所有相关的条件表达式都合并到一起。  
2.  可以考虑对合并后的条件表达式实施提炼函数。

## 37.  以卫语句取代嵌套条件表达式（Replace Nested Conditional with Guard Clauses）  

```javascript
function getPayAmount() {
  let result;
  if (isDead) result = deadAmount();
  else {
    if (isSeparated) result = separatedAmount();
    else {
      if (isRetired) result = retiredAmount();
      else result = normalPayAmount();
    }
  }
  return result;
}

// 重构后
function getPayAmount() {
  if (isDead) return deadAmount();
  if (isSeparated) return separatedAmount();
  if (isRetired) return retiredAmount();
  return normalPayAmount();
}
```

**条件表达式**通常有两种风格：

- 第一种风格是：两个条件分支 都属于正常行为。
- 第二种风格则是：只有一个条件分支是正常行为，另一个分支则是异常的情况。 

如果两条分支都是正常行为，就应该使用形如if...else...的条件表达式；

如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的单独检查常常被称为“卫语句”（guard clauses）。  

**动机：**当条件表达式中只有一个分支是正常行为，其他分支都是异常或罕见的情况时，可以使用卫语句来提前返回或抛出异常，从而减少嵌套层次，提高代码可读性。

**做法：**

1. 选中最外层需要被替换的条件逻辑，将其替换为卫语句。  （测试）
2.  有需要的话，重复上述步骤。  
3.  如果所有卫语句都引发同样的结果，可以使用合并条件表达式合并之。  

## 38.  以多态取代条件表达式（Replace Conditional with Polymorphism）  

```javascript
switch (bird.type) {
  case "EuropeanSwallow":
    return "average";
  case "AfricanSwallow":
    return bird.numberOfCoconuts > 2 ? "tired" : "average";
  case "NorwegianBlueParrot":
    return bird.voltage > 100 ? "scorched" : "beautiful";
  default:
    return "unknown";
}

// 重构后
class EuropeanSwallow {
  get plumage() {
    return "average";
  }
}
class AfricanSwallow {
  get plumage() {
    return this.numberOfCoconuts > 2 ? "tired" : "average";
  }
}
class NorwegianBlueParrot {
  get plumage() {
    return this.voltage > 100 ? "scorched" : "beautiful";
  }
}

    
```

**动机：**当条件表达式根据对象的类型来选择不同的行为时，可以使用多态来封装变化，从而避免重复代码，增加可扩展性。

**做法：**

1. 如果现有的类尚不具备多态行为，就用工厂函数创建之，令工厂函数返回恰当 的对象实例。  
2.  在调用方代码中使用工厂函数获得对象实例。  
3.  将带有条件逻辑的函数移到超类中。  

 如果条件逻辑还未提炼至独立的函数，首先对其使用提炼函数

1. 任选一个子类，在其中建立一个函数，使之覆写超类中容纳条件表达式的那个函数。将与该子类相关的条件表达式分支复制到新函数中，并对它进行适当调整。  
2. 重复上述过程，处理其他条件分支。  
3. 在超类函数中保留默认情况的逻辑。或者，如果超类应该是抽象的，就把该函数声明为abstract，或在其中直接抛出异常，表明计算责任都在子类中。 

## 39.  引入特例（Introduce Special Case）  

```javascript
if (aCustomer === "unknown") customerName = "occupant";

// 重构后
class UnknownCustomer {
	get name() {return "occupant";}
```

特例是一种设计模式，它的目的是为了处理某些特殊情况，比如空值、错误、缺省值等，而不是返回null或抛出异常。特例模式可以让客户端代码更简洁，更容易理解和维护。

一个通常需要特例处理的值就是null，这也是这个模式常被叫作“Null对 象”（Null Object）模式的原因——我喜欢说：Null对象是特例的一种特例。  

**动机：**当某个对象在某种特殊情况下需要特殊处理时，可以创建一个特例类来代替该对象，从而消除条件逻辑，简化客户端代码。

**做法：**我们从一个作为容器的数据结构（或者类）开始，其中包含一个属性，该属性就是我们要重构的目标。容器的客户端每次使用这个属性时，都需要将其与某 个特例值做比对。我们希望把这个特例值替换为代表这种特例情况的类或数据结构。  

1.  给重构目标添加检查特例的属性，令其返回false。  
2.  创建一个特例对象，其中只有检查特例的属性，返回true。  
3.  对“与特例值做比对”的代码运用提炼函数，确保所有客户端都使用这个新函数，而不再直接做特例值的比对。
4.  将新的特例对象引入代码中，可以从函数调用中返回，也可以在变换函数中生成。
5.  修改特例比对函数的主体，在其中直接使用检查特例的属性。（测试）  
6.  使用函数组合成类或函数组合成变换，把通用的特例处理逻辑都搬移到新建的特例对象中。  

 特例类对于简单的请求通常会返回固定的值，因此可以将其实现为字面记录（literal record）。  

1.  对特例比对函数使用内联函数，将其内联到仍然需要的地方。 

```javascript
// 定义用户类User
class User {
  constructor(name) {
    this.name = name;
  }

  // 定义getName方法
  getName() {
    return this.name;
  }
}

// 定义空用户类NullUser，继承自User
class NullUser extends User {
  constructor() {
    super(null);
  }

  // 重写getName方法，返回空字符串或提示信息
  getName() {
    return "No such user";
  }
}

// 定义UserService类，模拟一个可能返回null的方法getUserById
class UserService {
  constructor() {
    // 假设有一个用户列表
    this.users = [
      new User("Alice"),
      new User("Bob"),
      new User("Charlie")
    ];
  }

  // 根据id返回一个User对象，如果没有找到对应的用户，则返回null
  getUserById(id) {
    if (id >= 0 && id < this.users.length) {
      return this.users[id];
    } else {
      return null;
    }
  }
}

// 创建一个UserService实例
let userService = new UserService();

// 测试getUserById方法，分别用有效和无效的id
let user1 = userService.getUserById(1); // 返回User对象
let user2 = userService.getUserById(3); // 返回null

// 如果直接调用user2.getName()，会抛出空指针异常
// console.log(user2.getName()); // TypeError: Cannot read property 'getName' of null

// 使用特例模式，当getUserById返回null时，用NullUser代替，并调用NullUser.getName()
user2 = user2 || new NullUser(); // 如果user2为null，则赋值为NullUser对象

// 调用NullUser.getName()，不会出现异常，而是返回空字符串或提示信息
console.log(user2.getName()); // No such user
```

## 40.  引入断言（Introduce Assertion）

```javascript
if (this.discountRate)
	base = base - (this.discountRate * base);

// 重构后
assert(this.discountRate>= 0);
if (this.discountRate)
	base = base - (this.discountRate * base);
```

**动机：**当某个条件必须为真才能继续执行后续代码时，可以使用断言来检查该条件，并在不满足时抛出异常，从而保证程序的正确性和完整性。

**做法：**如果你发现代码假设某个条件始终为真，就加入一个断言明确说明这种情况。  

因为断言应该不会对系统运行造成任何影响，所以“加入断言”永远都应该是 行为保持的。 

```javascript
// 定义getDiscount函数
function getDiscount(price, level) {
  // 如果price或level为空，返回原价
  if (!price || !level) {
    return price;
  }

  // 根据level计算折扣率
  let discount;
  if (level === "gold") {
    discount = 0.8;
  } else if (level === "silver") {
    discount = 0.9;
  } else {
    discount = 1;
  }

  // 返回折扣后的价格
  return price * discount;
}

// 这个代码有两个问题，一是没有对参数进行有效性检查，
// 二是没有明确表达对level参数的假设。我们可以用引入断言的重构手法来改进这个代码：

// 引入assert模块
const assert = require('assert');

// 定义getDiscount函数
function getDiscount(price, level) {
  // 使用断言检查参数是否有效，如果无效，则抛出错误
  assert(price > 0, "price must be positive");
  assert(level === "gold" || level === "silver" || level === "normal", "level must be gold, silver or normal");

  // 根据level计算折扣率
  let discount;
  if (level === "gold") {
    discount = 0.8;
  } else if (level === "silver") {
    discount = 0.9;
  } else {
    discount = 1;
  }

  // 返回折扣后的价格
  return price * discount;
}
```

## 41.  将查询函数和修改函数分离（Separate Query from Modifier）   

```javascript
function getTotalOutstandingAndSendBill() {
  const result = customer.invoices.reduce((total, each) => each.amount + total, 0);
  sendBill();
  return result;
}

// 重构后
function totalOutstanding() {
	return customer.invoices.reduce((total, each) => each.amount + total, 0);
}
function sendBill() {
	emailGateway.send(formatBill(customer));
}
```

**动机：**一条好规则是，任何有返回值的函数，都不应该有看得到的副作用。这样可以使函数的职责更加清晰，避免混乱和错误。

**做法：**建立两个不同的函数，其中一个负责查询，另一个负责修改。

1. 新建一个函数，令它的返回值与原函数相同
2. 修改原函数，令它调用查询函数，并返回获得的结果
3. 将调用原函数的代码改为调用查询函数。然后，在调用查询函数的那一行之前，加上对原函数的调用。
4. 将原函数的返回值改为void，并删掉其中所有的return语句

## 41.  将查询函数和修改函数分离（Separate Query from Modifier）   

```javascript
function getTotalOutstandingAndSendBill() {
  const result = customer.invoices.reduce((total, each) => each.amount + total, 0);
  sendBill();
  return result;
}

// 重构后
function totalOutstanding() {
	return customer.invoices.reduce((total, each) => each.amount + total, 0);
}
function sendBill() {
	emailGateway.send(formatBill(customer));
}
```

**动机：**一条好规则是，任何有返回值的函数，都不应该有看得到的副作用。这样可以使函数的职责更加清晰，避免混乱和错误。

**做法：**建立两个不同的函数，其中一个负责查询，另一个负责修改。

1. 新建一个函数，令它的返回值与原函数相同
2. 修改原函数，令它调用查询函数，并返回获得的结果
3. 将调用原函数的代码改为调用查询函数。然后，在调用查询函数的那一行之前，加上对原函数的调用。
4. 将原函数的返回值改为void，并删掉其中所有的return语句

## 42. 函数参数化（Parameterize Function）

```javascript
function tenPercentRaise(aPerson) {
  aPerson.salary = aPerson.salary.multiply(1.1);
}
function fivePercentRaise(aPerson) {
  aPerson.salary = aPerson.salary.multiply(1.05);
}

// 重构后
function raise(aPerson, factor) {
  aPerson.salary = aPerson.salary.multiply(1 + factor);
}
```

**动机：**去除重复代码，提高灵活性。

**做法：**

- 新建一个带有参数的函数，使它可以替换先前所有的重复性函数
- 将调用旧函数的代码改为调用新函数
- 对所有旧函数重复上述步骤，每次替换后，修改并测试

## 44. 保持对象完整（Preserve Whole Object）

```javascript
const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.high;
if (aPlan.withinRange(low, high))

// 重构后
if (aPlan.withinRange(aRoom.daysTempRange))
```

**动机：**当你从一个对象中取出若干值，将它们作为某一次函数调用的参数时，就应该考虑使用这个重构手法。这样可以让函数更容易理解和修改。

**做法：**

1. 将这些值所属的整个对象传递给函数。
2. 如果还没有定义一个完整对象，就先使用引入参数对象来创建一个。
3. 如果函数不属于这个对象所在的类，就考虑使用搬移函数来移动它。

```javascript
// 重构前
function getLowestTemperature(reading) {
  return Math.min(reading.temp1, reading.temp2, reading.temp3);
}

function getHighestTemperature(reading) {
  return Math.max(reading.temp1, reading.temp2, reading.temp3);
}

function getAverageTemperature(reading) {
  return (reading.temp1 + reading.temp2 + reading.temp3) / 3;
}

// 重构后
class Reading {
  constructor(data) {
    this._data = data;
  }

  get temp1() {
    return this._data.temp1;
  }
  get temp2() {
    return this._data.temp2;
  }
  get temp3() {
    return this._data.temp3;
  }

  get lowestTemperature() {
    return Math.min(this.temp1, this.temp2, this.temp3);
  }

  get highestTemperature() {
    return Math.max(this.temp1, this.temp2, this.temp3);
  }

  get averageTemperature() {
    return (this.temp1 + this.temp2 + this.temp3) / 3;
  }
}
```

## 45.  以查询取代参数（Replace Parameter with Query）  

```javascript
availableVacation(anEmployee, anEmployee.grade);
function availableVacation(anEmployee, grade) {
  // calculate vacation...

// 重构后
availableVacation(anEmployee)
function availableVacation(anEmployee) {
  const grade = anEmployee.grade;
  // calculate vacation...
```

**动机：**消除一些不必要的参数，使得函数更加简洁和清晰。

**反向重构：**以参数取代查询

**做法：**

1. 将参数的计算过程提炼到一个独立的函数中
2. 原函数中调用这个函数

```javascript
// 以参数取代查询
function getDiscountedPrice(basePrice, season) {
  let discountFactor;
  if (season === "summer") {
    discountFactor = 0.1;
  } else if (season === "winter") {
    discountFactor = 0.2;
  } else {
    discountFactor = 0;
  }
  return basePrice * (1 - discountFactor);
}

// 重构后：以查询取代参数
function getDiscountedPrice(basePrice) {
  return basePrice * (1 - getDiscountFactor());
}

function getDiscountFactor() {
  let season = getCurrentSeason();
  if (season === "summer") {
    return 0.1;
  } else if (season === "winter") {
    return 0.2;
  } else {
    return 0;
  }
}
```

## 46. 以参数取代查询（Replace Query with Parameter）

```javascript
targetTemperature(aPlan)
function targetTemperature(aPlan) {
  currentTemperature = thermostat.currentTemperature;
  // rest of function...

// 重构后
targetTemperature(aPlan, thermostat.currentTemperature)
function targetTemperature(aPlan, currentTemperature) {
  // rest of function...
```

**动机：**为了解决一些引用关系的问题，比如引用一个全局变量或者一个想要移除的元素。

**反向重构：**以查询取代参数

**做法：**

1. 对执行查询操作的代码使用提炼变量将其从函数体中分离出来
2. 函数体代码已经不再执行查询操作, 对这部分代码使用提炼函数
3. 内联变量，消除刚才提炼出来的变量
4. 对原来的函数使用内联函数

```javascript
// 以查询取代参数
function getDiscountedPrice(basePrice) {
  return basePrice * (1 - getDiscountFactor());
}

function getDiscountFactor() {
  let discount = getGlobalDiscount();
  if (discount > 0.5) {
    return 0.5;
  } else {
    return discount;
  }
}

// 重构后：以参数取代查询
// 以参数取代查询可以避免引用一个全局变量getGlobalDiscount()，从而使得函数更加独立和可测试。
function getDiscountedPrice(basePrice, discount) {
  let discountFactor = getDiscountFactor(discount);
  return basePrice * (1 - discountFactor);
}

function getDiscountFactor(discount) {
  if (discount > 0.5) {
    return 0.5;
  } else {
    return discount;
  }
}
```

## 47. 移除设值函数（Remove Setting Method）

```javascript
class Person {
  get name() {...}
  set name(aString) {...}

// 重构后
class Person {
  get name() {...}
```

**动机：**如果为某个字段提供了设值函数，这就暗示这个字段可以被改变。如果不希望在对象创建之后此字段还有机会被改变，那就不要为它提供设值函数（同时将该字段声明为不可变）。

**做法：**

1. 检查设值函数被使用的情况，看它是否只被构造函数调用。
2. 如果是，就将该字段声明为 final，并去掉设值函数。

## 48. 以工厂函数取代构造函数（Replace Constructor with Factory Function）

```javascript
leadEngineer = new Employee(document.leadEngineer, "E");

// 重构后
leadEngineer = createEngineer(document.leadEngineer);
```

**动机：**在创建对象时不仅仅是做简单的构造动作，而是可以根据类型码或其他条件来创建不同的子类对象。

**做法：**

1. 新建一个工厂函数。
2. 调用现有的构造函数或者子类的构造函数。

## 49.  以命令取代函数（Replace Function with Command）  

```javascript
function score(candidate, medicalExam, scoringGuide) {
  let result = 0;
  let healthLevel = 0;
  // long body code
}

// 重构后
class Scorer {
  constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate;
    this._medicalExam = medicalExam;
    this._scoringGuide = scoringGuide;
  }
  execute() {
    this._result = 0;
    this._healthLevel = 0;
    // long body code
  }
}
```

**动机：**将一个复杂的函数封装成一个类，使得代码更清晰可读，也方便提供撤销操作。

**反向重构：**以函数取代命令

**做法：**

1. 新建一个空的类
2. 用搬移函数将函数搬移到这个新的类
3. 将原来的函数变成一个简单的委托调用

```javascript
// 原来的函数
function score(candidate, medicalExam, scoringGuide) {
  let result = 0;
  let healthLevel = 0;
  let highMedicalRiskFlag = false;

  if (medicalExam.isSmoker) {
    healthLevel += 10;
    highMedicalRiskFlag = true;
  }
  
  // more code ...

  return result;
}

// 使用以命令取代函数后
class Scorer {
  constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate;
    this._medicalExam = medicalExam;
    this._scoringGuide = scoringGuide;
    this._result = 0;
    this._healthLevel = 0;
    this._highMedicalRiskFlag = false;
  }

  execute() {
    if (this._medicalExam.isSmoker) {
      this._healthLevel += 10;
      this._highMedicalRiskFlag = true;
    }
    
    // more code ...

    return this._result; 
  }
}

// 原来的函数变成委托调用
function score(candidate, medicalExam, scoringGuide) {
   return new Scorer(candidate, medicalExam, scoringGuide).execute();
}
```

**什么是命令？**

命令是一种封装了请求的对象，它可以让请求发送者和请求接收者解耦，也可以支持撤销操作。命令模式是一种使用命令对象的设计模式，它有四个角色：

\- 调用者：负责发起命令请求

\- 接收者：负责执行命令

\- 命令：连接调用者和接收者，包含执行逻辑

\- 客户端：创建具体的命令对象，并设置调用者

```
// 接收者
class Receiver {
  action() {
    console.log("执行操作");
  }
}

// 命令
class Command {
  constructor(receiver) {
    this.receiver = receiver;
  }

  execute() {
    this.receiver.action();
  }
}

// 调用者
class Invoker {
  constructor(command) {
    this.command = command;
  }

  call() {
    console.log("发起命令");
    this.command.execute();
  }
}

// 客户端
let receiver = new Receiver();
let command = new Command(receiver);
let invoker = new Invoker(command);
invoker.call(); // 输出 "发起命令" "执行操作"
```

## 50. 以函数取代命令（Replace Command with Function）

```javascript
class ChargeCalculator {
  constructor(customer, usage) {
    this._customer = customer;
    this._usage = usage;
  }
  execute() {
    return this._customer.rate * this._usage;
  }
}

// 重构后
function charge(customer, usage) {
  return customer.rate * usage;
}
```

**动机：**将一个类封装的命令对象简化成一个函数，使得代码更简洁高效，减少不必要的开销。

**反向重构：**以命令取代函数

**做法：**

1.  提炼函数把“创建并执行命令对象”的代码单独提炼到一个函数中。
2.  对命令对象在执行阶段用到的函数，逐一使用内联函数。
3.  使用改变函数声明，把构造函数的参数转移到执行函数
4.  对于所有的字段，在执行函数中找到引用它们的地方，并改为使用参数。每次修改后都要测试。
5.  把“调用构造函数”和“调用执行函数”两步都内联到调用方（也就是最终要替换命令对象的那个函数）。
6.  用移除死代码把命令类消去。

## 50. 以函数取代命令（Replace Command with Function）

```javascript
class ChargeCalculator {
  constructor(customer, usage) {
    this._customer = customer;
    this._usage = usage;
  }
  execute() {
    return this._customer.rate * this._usage;
  }
}

// 重构后
function charge(customer, usage) {
  return customer.rate * usage;
}
```

**动机：**将一个类封装的命令对象简化成一个函数，使得代码更简洁高效，减少不必要的开销。

**反向重构：**以命令取代函数

**做法：**

1.  提炼函数把“创建并执行命令对象”的代码单独提炼到一个函数中。
2.  对命令对象在执行阶段用到的函数，逐一使用内联函数。
3.  使用改变函数声明，把构造函数的参数转移到执行函数
4.  对于所有的字段，在执行函数中找到引用它们的地方，并改为使用参数。每次修改后都要测试。
5.  把“调用构造函数”和“调用执行函数”两步都内联到调用方（也就是最终要替换命令对象的那个函数）。
6.  用移除死代码把命令类消去。

## 51. 函数上移（Pull Up Method）

```javascript
class Employee {...}
class Salesman extends Employee {
  get name() {...}
}
class Engineer extends Employee {
  get name() {...}
}

// 重构后
class Employee {
  get name() {...}
}
class Salesman extends Employee {...}
class Engineer extends Employee {...}
```

**动机：**避免在子类中重复相同的函数。

**反向重构：**函数下移

**做法：**

1. 检查待提升函数，确定它们是完全一致的。
2. 如果函数签名不同，先弄成一样的。
3. 在超类中新建一个函数，将某一个待提升函数的代码复制过去。
4. 在子类中删除原来的函数，并调用超类中的新函数。

## 52. 字段上移（Pull Up Field）

```javascript
class Employee {...} // Java
class Salesman extends Employee {
  private String name;
}
class Engineer extends Employee {
  private String name;
}

// 重构后
class Employee {
  protected String name;
}
class Salesman extends Employee {...}
class Engineer extends Employee {...}
```

**动机：**用于处理继承体系中的相同字段。当两个或多个子类拥有相同的字段时，可以将该字段移至超类，以消除重复代码和提高内聚性。

**反向重构：**字段下移

**做法：**

1. 针对待提升之字段，检查它们的所有使用点，确认它们以同样的方式被使用。
2. 如果这些字段的名称不同，先将它们改名，使每一个名称都和你想为超类字段取的名称相同。
3. 在超类中新建一个字段。
4. 移除子类中的字段。

## 53. 构造函数本体上移（Pull Up Constructor Body）

```javascript
class Party {...}
class Employee extends Party {
  constructor(name, id, monthlyCost) {
    super();
    this._id = id;
    this._name = name;
    this._monthlyCost = monthlyCost;
  }
}

// 重构后
class Party {
  constructor(name){
    this._name = name;
  }
}
class Employee extends Party {
  constructor(name, id, monthlyCost) {
    super(name);
    this._id = id;
    this._monthlyCost = monthlyCost;
  }
}
```

**动机：**它的目的是消除子类中相同或类似的构造函数代码，提高代码的复用性和可维护性。

**做法：**

1. 在超类中定义一个构造函数。
2. 将子类中相同或类似的构造函数代码复制到超类的构造函数中。
3. 在子类中调用超类的构造函数，并传递相应的参数。
4. 删除子类中不再需要的构造函数代码。

```javascript
// 子类Employee
class Employee {
  constructor(name, id) {
    this.name = name;
    this.id = id;
    // 其他共同或相似的代码
  }
}

// 子类Manager
class Manager {
  constructor(name, id, department) {
    this.name = name;
    this.id = id;
    this.department = department;
    // 其他共同或相似的代码
  }
}

// 重构后

// 超类Person
class Person {
  constructor(name, id) {
    this.name = name;
    this.id = id;
    // 其他共同或相似的代码
  }
}

// 子类Employee
class Employee extends Person {
  constructor(name, id) {
    super(name, id); // 调用超类的构造函数
  }
}

// 子类Manager
class Manager extends Person {
  constructor(name, id, department) {
    super(name, id); // 调用超类的构造函数
    this.department = department;
  }
}
```

## 54. 函数下移（Push Down Method）

```javascript
class Employee {
  get quota {...}
}
class Engineer extends Employee {...}
class Salesman extends Employee {...}

// 重构后
class Employee {...}
class Engineer extends Employee {...}
class Salesman extends Employee {
  get quota {...}
}
```

**动机：**超类中的某个函数只与部分子类有关的情况，将这个函数移到相关的子类中去。这样可以减少超类和子类之间的耦合，也可以避免不必要的函数调用。

**反向重构：**函数上移

**做法：**

1.  将超类中的函数本体复制到每一个需要此函数的子类中。
2.  删除超类中的函数。
3.  将该函数从所有不需要它的那些子类中删除。

```javascript
// 函数下移前

// 超类
class Animal {
  constructor(name) {
    this.name = name;
  }

  // 这个函数只与Dog和Cat有关
  makeSound() {
    console.log(this.name + " makes a sound.");
  }
}

// 子类
class Dog extends Animal {
  constructor(name) {
    super(name);
  }
}

class Cat extends Animal {
  constructor(name) {
    super(name);
  }
}

class Fish extends Animal {
  constructor(name) {
    super(name);
  }
}

// 测试
let dog = new Dog("Spot");
let cat = new Cat("Fluffy");
let fish = new Fish("Nemo");

dog.makeSound(); // Spot makes a sound.
cat.makeSound(); // Fluffy makes a sound.
fish.makeSound(); // Nemo makes a sound.

// 函数下移后

// 超类
class Animal {
  constructor(name) {
    this.name = name;
  }

  // 删除或抽象这个函数
}

// 子类
class Dog extends Animal {
  constructor(name) {
    super(name);
  }

  // 在需要的子类中声明该函数
  makeSound() {
    console.log(this.name + " barks.");
  }
}

class Cat extends Animal {
  constructor(name) {
    super(name);
  }

  // 在需要的子类中声明该函数
  makeSound() {
    console.log(this.name + " meows.");
  }
}

class Fish extends Animal {
  constructor(name) {
    super(name);
  }

  // 不需要这个函数，删除它
}

// 测试
let dog = new Dog("Spot");
let cat = new Cat("Fluffy");
let fish = new Fish("Nemo");

dog.makeSound(); // Spot barks.
cat.makeSound(); // Fluffy meows.
fish.makeSound(); // TypeError: fish.makeSound is not a function.
```

## 55. 字段下移（Push Down Field）

```javascript
class Employee { // Java
  private String quota;
}
class Engineer extends Employee {...}
class Salesman extends Employee {...}

// 重构后
class Employee {...}
class Engineer extends Employee {...}
class Salesman extends Employee {
  protected String quota;
}
```

**动机：**超类中的某个字段只被部分子类用到的情况，将这个字段移到需要它的那些子类去。这样可以减少超类和子类之间的耦合，也可以避免不必要的字段占用内存。

**反向重构：**字段上移

**做法：**

1.  在所有需要该字段的子类中声明该字段。
2.  将该字段从超类中移除。
3.  将该字段从所有不需要它的那些子类中删掉。

## 56. 以子类取代类型码（Replace Type Code with Subclasses）

```javascript
function createEmployee(name, type) {
  return new Employee(name, type);
}

// 重构后
function createEmployee(name, type) {
  switch (type) {
    case "engineer": return new Engineer(name);
    case "salesman": return new Salesman(name);
    case "manager": return new Manager (name);
}
```

**动机：**借助多态来处理变化行为，把对不同类行为的了解从类用户那儿转移到了类自身。这样，如果需要添加新的行为变化，只需要添加一个子类就可以了，而不需要修改原来的类或者使用条件表达式。这也符合开闭原则，即对扩展开放，对修改关闭。

开闭原则是面向对象编程中的一个重要原则，它的英文全称是 Open-Closed Principle，简称 OCP。它的含义是，一个软件实体（类、模块、方法等）应该对扩展开放，对修改关闭。这意味着，我们可以在不改变原有代码的基础上，通过增加新的代码来增加新的功能或者改变原有功能。这样做可以提高软件的可维护性和可复用性，降低软件的耦合度和修改成本。

**反向重构：**移除子类

**做法：**

1.  自封装类型码字段 。
2.  任选一个类型码取值，为其创建一个子类。覆写类型码类的取值函数，令其返回该类型码的字面量值 。
3.  创建一个选择器逻辑，把类型码参数映射到新的子类 。
4.  针对每个类型码取值，重复上述“创建子类、添加选择器逻辑”的过程。每次修改后执行测试 。
5.  去除类型码字段 。
6.  使用函数下移和以多态取代条件表达式处理原本访问了类型码的函数。全部处理完后，就可以移除类型码的访问函数

```javascript
// 原始代码
class Employee {
  constructor(name, typeCode) {
    this._name = name;
    this._typeCode = typeCode;
  }

  get name() {
    return this._name;
  }
  get type() {
    return Employee.legalTypeCodes[this._typeCode];
  }

  static get legalTypeCodes() {
    return { E: "Engineer", M: "Manager", S: "Salesperson" };
  }
}

// 使用以子类取代类型码重构后
class Employee {
  constructor(name) {
    this._name = name;
  }

  get name() {
    return this._name;
  }
}

class Engineer extends Employee {
  get type() {
    return "Engineer";
  }
}

class Manager extends Employee {
  get type() {
    return "Manager";
  }
}

class Salesperson extends Employee {
  get type() {
    return "Salesperson";
  }
}
```

## 57. 移除子类（Remove Subclass）

```javascript
class Person {
  get genderCode() {
    return "X";
  }
}
class Male extends Person {
  get genderCode() {
    return "M";
  }
}
class Female extends Person {
  get genderCode() {
    return "F";
  }
}

// 重构后
class Person {
  get genderCode() {
    return this._genderCode;
  }
}
```

**动机：**随着软件的演化，子类所支持的变化可能被搬移到别处，甚至完全去除，这时子类就失去了价值。

子类存在着就有成本，阅读者要花心思去理解它的用意，所以如果子类的用处太少，就不值得存在了。此时，最好的选择就是移除子类，将其替换为超类中的一个字段。

**反向重构：**以子类取代类型码

**做法：**

1. 使用以工厂函数取代构造函数，把子类的构造函数包装到超类的工厂函数中。
2. 如果有任何代码检查子类的类型，先用提炼函数把类型检查逻辑包装起来，然后用搬移函数将其搬到超类。每次修改后执行测试。
3. 新建一个字段，用于代表子类的类型。
4. 将原本针对子类的类型做判断的函数改为使用新建的类型字段。
5. 删除子类。

移除子类和以子类取代类型码的界限

> - 移除子类是在子类所支持的变化已经被搬移到别处或者完全去除，导致子类失去了价值的情况下使用的重构手法。它的目的是简化继承体系，减少不必要的类。
> - 以子类取代类型码是在有一个不可变的类型码，它会影响类的行为，导致需要使用 switch 或 if-then-else 语句来处理不同类型码对应的逻辑的情况下使用的重构手法。它的目的是利用多态来处理变化行为，把对不同行为的了解从类用户转移到了类自身。

因此，移除子类和以子类取代类型码的界限在于是否需要继承体系来表示不同行为。如果需要，则可以使用以子类取代类型码；如果不需要，则可以使用移除子类。

```javascript
// 原始代码
class Employee {
  constructor(name) {
    this.name = name;
  }
}

class Engineer extends Employee {
  constructor(name) {
    super(name);
    this.type = "Engineer";
  }
}

class Salesman extends Employee {
  constructor(name) {
    super(name);
    this.type = "Salesman";
  }
}

// 使用重构手法：移除子类
class Employee {
  constructor(name, type) {
    this.name = name;
    this.type = type;
  }
}

function createEmployee(name, type) {
  return new Employee(name, type);
}
```

## 58. 提炼超类（Extract Superclass）

```javascript
class Department {
  get totalAnnualCost() {...}
  get name() {...}
  get headCount() {...}
}
class Employee {
  get annualCost() {...}
  get name() {...}
  get id() {...}
}
```

## 59. 折叠继承体系（Collapse Hierarchy）

```javascript
class Employee {...}
class Salesman extends Employee {...}

// 重构后
class Employee {...}
```

**动机：**当一个类与其超类已经没有多大的区别了，不值得再作为独立的类存在。

**做法：**

1. 选择想移除的类：是超类还是子类？ 我选择的依据是看哪个类的名字放在未来更有意义。如果两个名字都不够 好，我就随便挑一个。
2. 使用字段上移、字段下移、函数上移、函数下移，把所有元素都移到同一个类中。
3. 调整即将被移除的那个类的所有引用点，令它们改而引用合并后留下的类。
4. 移除我们的目标；此时它应该已经成为一个空类。

折叠继承体系涉及到继承关系，而内联类不一定涉及到继承关系。折叠继承体系是将子类和超类合并，而内联类是将一个类和它的客户或协作者合并。

## 60. 以委托取代子类（Replace Subclass with Delegate）

```javascript
class Order {
  get daysToShip() {
    return this._warehouse.daysToShip;
  }
}
class PriorityOrder extends Order {
  get daysToShip() {
    return this._priorityPlan.daysToShip;
  }
}

// 重构后
class Order {
  get daysToShip() {
    return this._priorityDelegate
      ? this._priorityDelegate.daysToShip
      : this._warehouse.daysToShip;
  }
}
class PriorityOrderDelegate {
  get daysToShip() {
    return this._priorityPlan.daysToShip;
  }
}
```

**动机：**如同状态（State）模式或者策略（Strategy）模式取代子类。这两个模式在结构上是相同的，都是由宿主对象把责任委托给另一个继承体系。

**做法：**

1. 如果构造函数有多个调用者，首先用以工厂函数取代构造函数把构造函数包装起来。
2. 创建一个空的委托类，这个类的构造函数应该接受所有子类特有的数据项，并 且经常以参数的形式接受一个指回超类的引用。
3. 在超类中添加一个字段，用于安放委托对象。
4. 修改子类的创建逻辑，使其初始化上述委托字段，放入一个委托对象的实例。
5. 选择一个子类中的函数，将其移入委托类。
6. 使用搬移函数手法搬移上述函数，不要删除源类中的委托代码。
7. 如果被搬移的源函数还在子类之外被调用了，就把留在源类中的委托代码从子 类移到超类，并在委托代码之前加上卫语句，检查委托对象存在。如果子类之 外已经没有其他调用者，就用移除死代码去掉已经没人使用的委托代 码。
8. 重复上述过程，直到子类中所有函数都搬到委托类。
9. 找到所有调用子类构造函数的地方，逐一将其改为使用超类的构造函数。
10. 运用移除死代码去掉子类。

## 61. 以委托取代超类（Replace Superclass with Delegate）

```javascript
class List {...}
class Stack extends List {...}

// 重构后
class Stack {
  constructor() {
    this._storage = new List();
  }
}
class List {...}
```

**动机：**当子类需要从多个源头继承行为，而语言不支持多重继承。

**做法：**

1. 在子类中新建一个字段，使其引用超类的一个对象，并将这个委托引用初始化 为超类的新实例。
2. 针对超类的每个函数，在子类中创建一个转发函数，将调用请求转发给委托引 用。每转发一块完整逻辑，都要执行测试。
3. 当所有超类函数都被转发函数覆写后，就可以去掉继承关系。