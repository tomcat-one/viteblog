import{_ as o,c as t,o as e,a2 as r}from"./chunks/framework.Bx6qu0xe.js";const a="/assets/4.DYBq848U.png",_=JSON.parse('{"title":"为什么要扒屎","description":"","frontmatter":{},"headers":[],"relativePath":"note/reconstitution/1.1为什么要扒屎.md","filePath":"note/reconstitution/1.1为什么要扒屎.md"}'),n={name:"note/reconstitution/1.1为什么要扒屎.md"},p=r(`<h1 id="为什么要扒屎" tabindex="-1">为什么要扒屎 <a class="header-anchor" href="#为什么要扒屎" aria-label="Permalink to &quot;为什么要扒屎&quot;">​</a></h1><h2 id="_1-何为重构" tabindex="-1">1.何为重构 <a class="header-anchor" href="#_1-何为重构" aria-label="Permalink to &quot;1.何为重构&quot;">​</a></h2><p><strong>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本，以改进程序的内部结构。</strong></p><blockquote><p>例如提炼函数和以多态取代条件表达式。</p></blockquote><p><strong>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</strong></p><blockquote><p>如果有人说他们的代码在重构过程中有一两天时间不可用，基本上可以确定，他们在做的事不是重构。</p></blockquote><p><strong>重构与性能优化有很多相似之处：两者都需要修改代码，并且两者都不会改变程序的整体功能。</strong></p><p><strong>两者的差别在于其目的：重构是为了让代码“更容易理解， 更易于修改”。这可能使程序运行得更快，也可能使程序运行得更慢。</strong></p><blockquote><p>重构是一种经千锤百炼形成的有条不紊的程序整理方法，可以最大限度地减小整理过程中引入错误的概率。</p></blockquote><p>本质上说，重构就是在代码写好之后改进它的设计。</p><h2 id="_2-重构的原来" tabindex="-1">2.重构的原来 <a class="header-anchor" href="#_2-重构的原来" aria-label="Permalink to &quot;2.重构的原来&quot;">​</a></h2><p><strong>重构改进软件的设计</strong></p><pre><code>如果没有重构，程序的内部设计（或者叫架构）会逐渐腐败变质 。
</code></pre><p>完成同样一件事，设计欠佳的程序往往需要更多代码，这常常是因为代码在不同的地方使用完全相同的语句做同样的事，因此改进设计的一个重要方向就是 <strong>消除重复代码</strong>。</p><p>代码量减少并不会使系统运行更快，因为这对程序的资源占用几乎没有任何明显影响。</p><p>然而代码量减少将使未来可能的程序修改动作容易得多。</p><p><strong>重构使软件更容易理解</strong></p><pre><code>重构可以让代码更易读,未来出现的那个开发者大多数是自己
</code></pre><p><strong>重构帮助找到 bug</strong></p><pre><code>深入理解代码的所作所为，并立即把新的理解反映在代码当中,重构能够帮助更有效地写出**健壮的代码**
</code></pre><p>健壮的代码是指一个代码能够抵抗干扰，比如说一些非法的输入，异常，还有一些意料之外的错误的能力。健壮的代码不仅要能够正确地运行，还要能够容易地理解和维护。</p><p>要写出健壮的代码，需要遵循一些规范和原则，比如分层、命名、注释、异常处理等。还需要使用一些工具和技巧，比如单元测试、代码审查、重构等。</p><p><strong>重构提高编程速度</strong></p><pre><code>设计耐久性假说 ：通过投入精力改善内部设计，我们增加了软件的耐久性，从而可以更长时间地保持开发的快速。
</code></pre><p><img src="`+a+'" alt="这是图片" title="Magic Gardens"></p><blockquote><p>”良好的设计必须在开始编程之前完成，因为一旦开始编写代码，设计就只会逐渐腐败。“ 然而重构改变了这个图景。现在我们可以改善已有代码的设计，因此我们可以先做一个设计，然后不断改善它，哪怕程序本身的功能也在不断发生着变化。由于预先做出良好的设计非常困难，想要既体面又快速地开发功能，重构必不可少。</p></blockquote><h2 id="_3-何时重构" tabindex="-1">3.何时重构 <a class="header-anchor" href="#_3-何时重构" aria-label="Permalink to &quot;3.何时重构&quot;">​</a></h2><blockquote><p>第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。</p></blockquote><p>**预备性重构：**让添加新功能更容易</p><blockquote><p>重构的最佳时机就在添加新功能之前</p></blockquote><p>**帮助理解的重构：**使代码更易懂</p><blockquote><p>给一两个变量改名，让它们更清楚地表达意图，以方便理解<br> 或是将一个长函数拆成几个小函数</p></blockquote><p><strong>捡垃圾式重构</strong></p><blockquote><p>如果我发现的垃圾很容易重构，我会马上重构它；如果重构需要花一些精力，我可能会拿一张便笺纸把它记下来，完成当下的任务再回来重构它。<br> 有时这样的垃圾需要好几个小时才能解决，而我又有更紧急的事要完成。不过即便如此，稍微花一点工夫做一点儿清理，通常都是值得的。</p></blockquote><p><strong>有计划的重构和见机行事的重构</strong><br> 我的项目计划上没有专门留给重构的时间，绝大多数重构都在我做其他事的过程中自然发生。 如果团队过去忽视了重构，那么常常会需要专门花一些时间来优化代码库，以便更容易添加新功能。 在重构上花一个星期的时间，会在未来几个月里发挥价值。有时，即便团队做了日常的重构，还是会有问题在某个区域逐渐累积长大，最终需要专门花些时间来 解决。但这种有计划的重构应该很少，大部分重构应该是不起眼的、见机行事的。</p><blockquote><p>肮脏的代码必须重构，但漂亮的代码也需要很多重构。 新功能的到来可能使得代码不再合理。 我听过的一条建议是：将重构与添加新功能在版本控制的提交中分开。这样做的一大好处是可以各自独立地审阅和批准这些提交。但我并不认同这种做法。 重构常常与新添功能紧密交织，不值得花工夫把它们分开。并且这样做也使重构 脱离了上下文，使人看不出这些“重构提交”的价值。每个团队应该尝试并找出适 合自己的工作方式，只是要记住：分离重构提交并不是毋庸置疑的原则，只有当 你真的感到有益时，才值得这样做。</p></blockquote><h2 id="_4-长期重构" tabindex="-1">4.长期重构 <a class="header-anchor" href="#_4-长期重构" aria-label="Permalink to &quot;4.长期重构&quot;">​</a></h2><p>有一些大型的重构可能要花上几个星期，例如要替换一个正在使用的库，或者将整块代码抽取到一个组件中并共享给另一支团队使用，再或者要处理一大堆混乱的依赖关系，等等。<br> 即便在这样的情况下，我仍然不愿让一支团队专门做重构。可以让整个团队达成共识，在未来几周时间里逐步解决这个问题，这经常是一个有效的策略。<br> 每当有人靠近“重构区”的代码，就把它朝想要改进的方向推动一点。这个策略的好处在于，重构不会破坏代码——每次小改动之后，整个系统仍然照常工作。例如，如果想替换掉一个正在使用的库，可以先引入一层新的抽象，使其兼容新旧两个库的接口。一旦调用方已经完全改为使用这层抽象，替换下面的库就会容易得多。（这个策略叫作 Branch By Abstraction）</p><h2 id="_5-复审代码时重构" tabindex="-1">5.复审代码时重构 <a class="header-anchor" href="#_5-复审代码时重构" aria-label="Permalink to &quot;5.复审代码时重构&quot;">​</a></h2><p><strong>代码复审</strong> 代码复审有助于在开发团队中传播知识，也有助于让较有经验的开发者把知识传递给比较欠缺经验的人，并帮助更多人理解大型软件系统中的更多部分 。 代码复审对于编写清晰代码也很重要<br> 代码复审也让更多人有机会提出有用的建议<br><strong>重构对代码复审的作用</strong> 重构可以帮助我复审别人的代码</p><blockquote><p>开始重构前我可以先阅读代码， 得到一定程度的理解，并提出一些建议。一旦想到一些点子，我就会考虑是否可以通过重构立即轻松地实现它们。如果可以，我就会动手。这样做了几次以后， 我可以更清楚地看到，当我的建议被实施以后，代码会是什么样。</p></blockquote><p>重构还可以帮助代码复审工作得到更具体的结果</p><blockquote><p>不仅获得建议，而且其中许多建议能够立刻实现。最终你将从实践中得到比以往多得多的成就感。<br> 至于如何在代码复审的过程中加入重构，这要取决于复审的形式。在常见的 pull request 模式下，复审者独自浏览代码，代码的作者不在旁边，此时进行重构效果并不好。如果代码的原作者在旁边会好很多，因为作者能提供关于代码的上 下文信息，并且充分认同复审者进行修改的意图。对我个人而言，与原作者肩并 肩坐在一起，一边浏览代码一边重构，体验是最佳的。这种工作方式很自然地导 向结对编程：在编程的过程中持续不断地进行代码复审 。</p></blockquote><p><strong>何时不应该重构</strong> 如果丑陋的代码能被隐藏在一个 API 之下，我就可以容忍它继续保持丑陋。只有当我需要理解其工作原理时，对其进行重构才有价值。 如果重写比重构还容易，就别重构了。这是个困难的决定。 如果不花一点儿时间尝试，往往很难真实了解重构一块代码的难度 。</p><h2 id="_6-重构的挑战" tabindex="-1">6.重构的挑战 <a class="header-anchor" href="#_6-重构的挑战" aria-label="Permalink to &quot;6.重构的挑战&quot;">​</a></h2><p><strong>延缓新功能开发</strong><br> 重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值。 至于预备性重构是否延缓开发，需要经验去判断重构的必要性和顺序。 <strong>代码所有权</strong><br> 我推荐团队代码所有制，这样一支团队里的成员都可以修改这个团队拥有的代码，即便最初写代码的是别人。<br> 程序员可能各自分工负责系统的不同区域，但这种责任应该体现为监控自己责任区内发生的修改，而不是简单粗暴地禁止别人修改。 <strong>分支</strong><br> 特性分支：集成困难；阻碍重构（适合开源项目） 持续集成 CI：每个成员至少每天向主干集成一次；便于重构（适合全职项目） <strong>测试</strong> 更愿意有自测试的代码，但如果没有，自动化重构的工具包也很好。<br> 另一种重构的流派：只使用一组经过验证是安全的重构手法。这个流派要求严格遵循重构的每个步骤，并且可用的重构手法是特定于语言的。使用这种方法，团队得以在测试覆盖率很低的大型代码库上开展一些有用的重构。（只做了解）</p><blockquote><p>自动化重构的工具包是指一些可以帮助开发者对代码进行自动化分析和修改的工具，它们通常基于语法树（AST）或者其他形式的代码表示，提供一些用于访问和转换代码的 API 或者 DSL。 js 和 ts 有一个 jscodeshift 的工具包，但是使用它必须对 AST 和重构的技巧有一定的掌握才能写出 codemod 脚本，而且不能处理复杂的情况。</p></blockquote><p><strong>遗留代码</strong></p><ol><li>只有在设计系统时就考虑到了测试，这样的系统才容易添加测试 修改代码的艺术》 ： 它建议你先找到程序的接缝，在接缝处插入测试，如此将系统置于测试覆盖之下</li><li>一旦跌进这个深坑，没有爬出来的捷径，这也是我强烈倡导从一开始就写能自测试的代码的原因</li></ol><p><strong>数据库</strong> 渐进式数据库设计[mf-evodb]和数据库重构[Ambler &amp; Sadalage] 借助数据迁移脚本，将数据库结构的修改与代码结合，使大规模的、涉及数据库的修改可以比较容易地开展</p><h2 id="_7-重构、架构和-yagni" tabindex="-1">7.重构、架构和 YAGNI <a class="header-anchor" href="#_7-重构、架构和-yagni" aria-label="Permalink to &quot;7.重构、架构和 YAGNI&quot;">​</a></h2><blockquote><p>重构极大地改变了人们考虑软件架构的方式。 我的职业生涯早期，我被告知：在任何人开始写代码之前，必须先完成软件的设计和架构。一旦代码写出 来，架构就固定了，只会因为程序员的草率对待而逐渐腐败。 重构改变了这种观点。有了重构技术，即便是已经在生产环境中运行了多年的软件，我们也有能力大幅度修改其架构。正如本书的副标题所指出的，<strong>重构可以改善既有代码的设计</strong> 。</p></blockquote><p>YAGNI （you arenʼt going to need it） 并不是“不做架构性思考”的意思， 是架构、设计与开发过程融合的一种工作方式，这种工作方式必须有重构作为基础才可靠。 演进式架构[Ford et al.]是一门仍在不断发展的学科，架构师们在不断探索有用的模式和实践，充分发挥迭代式架构决策的能力。</p><h2 id="_8-重构与性能" tabindex="-1">8.重构与性能 <a class="header-anchor" href="#_8-重构与性能" aria-label="Permalink to &quot;8.重构与性能&quot;">​</a></h2><p>先写出可调优的软件，然后调优它以求获得足够的速度 。 <strong>时间预算法</strong></p><blockquote><p>分解你的设计时就要做好预算，给每个组件预先分配一定资源，包括时间和空间占用<br> 通常只用于性能要求极高的实时系统 ，例如心率系统</p></blockquote><p><strong>持续关注法</strong></p><blockquote><p>要求任何程序员在任何时间做任何事时，都要设法保持系统的高性能</p></blockquote><p><strong>90％的优化工作都是白费劲的，因为被你优化的代码大多很少被执行</strong></p><blockquote><p>如果你对大多数程序进行分析，就会发现它把大半时间都耗费在一小半代码身上</p></blockquote><ul><li>在性能优化阶段，我首先应该用一个度量工具来监控程序的运行，让它告诉我程序中哪些地方大量消耗时间和空间 。</li><li>和重构一样，我会小幅度进行修改。每走一步都需要编译、测试，再次度量。如果没能提高性能，就应该撤销此次修改。</li><li>重构的确可能使软件变慢，但它使优化阶段的软件性能调优更容易，最终还是会得到好的效果。</li></ul>',61),s=[p];function l(c,i,b,u,g,d){return e(),t("div",null,s)}const q=o(n,[["render",l]]);export{_ as __pageData,q as default};
