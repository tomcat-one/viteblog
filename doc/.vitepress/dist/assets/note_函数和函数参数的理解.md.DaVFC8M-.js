import{_ as s,c as i,o as a,a2 as n}from"./chunks/framework.BiaOK9tN.js";const g=JSON.parse('{"title":"函数和函数参数的理解","description":"","frontmatter":{},"headers":[],"relativePath":"note/函数和函数参数的理解.md","filePath":"note/函数和函数参数的理解.md"}'),p={name:"note/函数和函数参数的理解.md"},t=n(`<h1 id="函数和函数参数的理解" tabindex="-1">函数和函数参数的理解 <a class="header-anchor" href="#函数和函数参数的理解" aria-label="Permalink to &quot;函数和函数参数的理解&quot;">​</a></h1><p>关于 js 函数和函数参数的理解：</p><p>1.函数不介意传来进来多少个参数，也不在乎传进来参数是什么数据类型。</p><blockquote><p>参数在内部是用一个数组来表示的</p><p>函数体内可以通过 arguments 对象来访问这个参数数组</p><p>arguments 对象只是与数组类似，并不是 Array 的实例</p></blockquote><p>2.命名的参数只提供遍历，但不是必须的</p><blockquote><p>解析器不会验证命名参数，其内部始终都是 arguments 对象</p><p>arguments 对象长度是由传入的参数个数决定的</p></blockquote><p>3.没有传递值的命名参数将自动被赋予 undefined 值</p><p>arguments 的值永远与对应命名参数的值保持同步</p><blockquote><p>在函数中，始终都是采用的值传递的方式</p></blockquote><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  obj.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;nicho&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(person);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(person.name); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//nicho</span></span></code></pre></div><p>此处函数参数 obj 与 person 并不是访问的同一个内存空间，它们的内存空间是相互独立的，但是它们的值会同步。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  obj.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;nicho&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  obj.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;greg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(person);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(person.name); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//nicho</span></span></code></pre></div><p>这个例子表明，person 并不是按引用传递的， 这说明即使在函数内部修改了参数的值，但原始引用仍旧保持不变。 实际上，当在函数内部重写 obj 时，这个变量引用的就是一个局部对象了，会在函数执行完毕之后立即进行销毁。</p><p>5.js 函数没有重载</p><blockquote><p>js 没有函数签名的概念，因为其参数是类数组 arguments 对象，类似于包含 0 或者多个值的数组。</p><p>可模仿重载，通过检验传入函数中的参数类型和数量并作出不同的反应。</p></blockquote>`,15),h=[t];function e(k,l,r,E,o,d){return a(),i("div",null,h)}const y=s(p,[["render",e]]);export{g as __pageData,y as default};
